{"meta":{"title":"众里寻他千百度","subtitle":null,"description":null,"author":"Raven","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-03-15T14:17:05.163Z","updated":"2019-03-15T14:17:05.163Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526 &#123; name: 'cofess' age: 22, gender: '男', profession: 'Web Developer &amp; Designer', experience: '大三', address: '合肥市', education: '本科', github: 'https://github.com/ravencoo', blog: 'https://blog.csdn.net/huijiaaa1', email: '857697474@qq.com', description: '这个世界上，最美好的就是自由', skills: [ ['Html', 'Javascript', 'jQuery', 'CSS'], ['spring', 'springboot','springmvc','spring JPA'], ['mybatis', 'hibernate'], ['dubbo', 'druid'], ['后端开发'] ], devTools: [ ['Sublime Text', 'Visual Studio Code', 'Notepad++'], ['IDEA', 'myeclipse'] ] &#125;"},{"title":"Repositories","date":"2019-03-15T12:35:52.133Z","updated":"2019-03-15T12:35:52.133Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-03-15T12:35:52.129Z","updated":"2019-03-15T12:35:52.129Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-03-15T12:35:52.130Z","updated":"2019-03-15T12:35:52.130Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-15T12:35:52.134Z","updated":"2019-03-15T12:35:52.134Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-03-15T12:35:52.132Z","updated":"2019-03-15T12:35:52.132Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"docker的初体验","date":"2019-03-21T14:21:42.993Z","updated":"2019-03-21T14:21:50.183Z","comments":true,"path":"2019/03/21/docker的初体验/","link":"","permalink":"http://yoursite.com/2019/03/21/docker的初体验/","excerpt":"","text":"早都听说过docker,但是一直却不知道它是什么?今天有时间就研究了一下怎么安装并使用 docker,特此记录一下。 首先呢，我们需要安装自己的一款虚拟机，具体教程可以百度。第二步，就是下载一款linux系统，这里我推荐使用centos。下载链接第三步，就是安装centos了，这些都不是最重要的，而且整个过程也很简单，就不一一记录了。1.安装好了centos之后，使用命令先安装 vim编译器：1yum -y install vim*2.因为docker 要求 CentOS 系统的内核版本高于 3.10,所以先通过1uname -r查看内核版本是否满足，如果小于3.10，那么使用以下命令更新内核。1sudo yum update运行以下命令1234567891011121314#安装一些必要的系统工具：sudo yum install -y yum-utils device-mapper-persistent-data lvm2添加软件源信息：sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo更新 yum 缓存：sudo yum makecache fast安装 Docker-ce：sudo yum -y install docker-ce运行dockersudo systemctl start docker想运行一个docker 的helloworld容器，但是却找不到。1sudo docker run hello-world这时候 进入 /etc/docker 目录，新建一个daemon.json文件（如果该文件存在，那么在后面追加内容即可）1234567# 新建文件touch daemon.json# 编辑文件vim /etc/docker#增加以下内容： &#123; &quot;storage-driver&quot;: &quot;devicemapper&quot;&#125;保存退出vim编辑器，然后就可以运行 helloworld 啦~ 最后想给docker容器安装一下 mysql，却发现查找不到。。解决方案：1234# 安装dig命令yum install bind-utilsdig @114.114.114.114 registry-1.docker.io运行完可见下图：再上面随便选择一个ip,最后呢，再修改hosts文件，12cd /etc vim hosts添加以下dns映射即可，之后退出vim。1234567891011121314151617#重启 docker容器。sudo service docker restart#查找musqldocker search mysql#安装msqldocker pull mysql#进入容器docker exec -it mysql bash#登录mysqlmysql -u root -pALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你要设置的密码&apos;;#添加远程登录用户CREATE USER &apos;你的昵称&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;你的密码&apos;;GRANT ALL PRIVILEGES ON *.* TO &apos;你的昵称&apos;@&apos;%&apos;;接着我们root用户使用Navicat连接容器的mysql,却报错Client does not support authentication protocol requested by server; consider upgrading MySQL，于是：123ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;你的密码&apos;;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;你的密码&apos;;SELECT plugin FROM mysql.user WHERE User = &apos;root&apos;;即可连接成功，最后想退出docker容器，注意不是关闭docker服务 ，因为我们刚才进入mysql容器，所以不用的时候可以退出docker命令。使用命令 exit 即可","categories":[],"tags":[]},{"title":"mybatis的总结(1)","slug":"mybatis总结","date":"2019-03-21T14:17:34.518Z","updated":"2019-03-21T14:16:41.551Z","comments":true,"path":"2019/03/21/mybatis总结/","link":"","permalink":"http://yoursite.com/2019/03/21/mybatis总结/","excerpt":"","text":"mybatis-config.xml 标签属性1234&lt;typeAliases&gt; &lt;typeAlias type=\"com.raven.pojo.hello\" alias=\"he\"/&gt; &lt;package name=\"com.ranve.bean\"/&gt;&lt;/typeAliases&gt;标签：为这个类起别名 ，不添加==alias==属性默认为 ==类名首字母小写== ，该值可以在==mapper.xml==文件的==resultType==属性种引用标签：为这个包的所有类起别名，类名首字母小写，为了防止 这个包下的实体类和子包的实体类名冲突，那么可以再类名上 用注解 ==@Alias(“value”)==起别名注意：别名用的时候不区分大小写1234567891011121314151617181920212223242526272829303132&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.passwd&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.passwd&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- databaseIdProvider 得到数据库厂商的表示，mybaits可以识别 在mapper.xml的属性 databaseId 种填写value的值即可--&gt;&lt;databaseIdProvider type=\"DB_VENDOR\"&gt; &lt;property name=\"MySQL\" value=\"mysql\"/&gt; &lt;property name=\"Oracle\" value=\"oracle\"/&gt; &lt;property name=\"SQL Server\" value=\"sqlserver\"/&gt;&lt;/databaseIdProvider&gt;可以通过标签的==default==属性指定数据源mapper标签详解：12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.raven.dao.PayMapper\"&gt; &lt;insert parameterType=\"com.raven.pay\" id=\"insertPay\"&gt; insert into t_pay(id,paytime,payname) values(0,#&#123;paytime&#125;,# &#123;payname&#125;) &lt;/insert&gt; &lt;select resultType=\"com.raven.pay\" id=\"selectPay\"&gt; select id,paytime,paytime from t_pay where id=#&#123;id&#125; &lt;/select&gt; &lt;update id=\"updatePay\"&gt; updata t_pay set payname=#&#123;payname&#125;,paytime=#&#123;paytime&#125; &lt;/update&gt; &lt;delete id=\"deletePay\"&gt; delete from t_pay whereid=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt;==parameterType==的意思是传来的参数类型，mybatis后面生成sql语句，会自动取出该对象的属性值到对应的#{}表达式中，==paramterType一般也可以省略不写==。==resultType==的意思是返回的参数类型，就是查询出来mybatis会给你把查出来的参数封装成一个对象。==id==属性又是什么意思呢？这个也是必须写的，你有没有想过一个问题，就是为什么我们只写一个接口mapper,再写一个mapper.xml文件，然后调用 sqlsession.getMapper(T class);就可以直接调用里面的方法呢？这个对象是谁实现的呢？mybatis为我们构造mapper代理对象的时候通过==namespace.id==实现了该接口的每个方法，它的原理就是这么来的。另外呢，对于mysql数据库而言，平时我们插入数据之后，有可能想获取自增后id的值，那么只需要再==insert==标签 使用如下两个属性即可123&lt;insert parameterType=\"com.raven.pay\" id=\"insertPay\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into t_pay(id,paytime,payname) values(0,#&#123;paytime&#125;,# &#123;payname&#125;)&lt;/insert&gt;==useGeneratedKeys==表示自增主键获取主键值策略==keyProperty==表示获取到主键值以后，将这个值封装给javaBean的那个属性值中。而对于 Oracle数据库而言就稍微麻烦一点了。如下：123456&lt;insert parameterType=\"com.raven.pay\" id=\"insertPay\" databaseId=\"oracle\"&gt; &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"Integer\"&gt; select PAY_SEQ.nextval from dual &lt;/selectKey&gt; insert into t_pay(id,paytime,payname) values(#&#123;id&#125;,#&#123;paytime&#125;,# &#123;payname&#125;)&lt;/insert&gt;运行过程：先运行selectKey查出id,然后再封装给javabean的属性。==注意：这里使用了databaseId属性，也就是说你需要再 mybatis-config.xml中配置该数据库的厂商信息==mybatis多个参数查询 注意事项多参数 查询 方法参数需注解 ==@Param==，不加的话，那么会抛出异常，如若不想加@Param,还有一种解决方案就是把sql语句的id=#{id }改成 id=#{param1},#{payname}改成 #{param2},因为mybatis底层默认是把参数封装到map里，所以我们可以用 #{param1}…..#{paramn}取参数，也可以把param换成arg ,即用#{arg0}取值。==如果该方法参数是个list类型，那么可以通过 #{list[0]}…#{list[n]}取到值==mapper1public Pay getPay(@Param(&quot;id&quot;)Stirng id,@Param(&quot;payname&quot;)String payname);mapper.xml123&lt;select id=\"getPay\" resultType=\"com.raven.pojo.Pay\"&gt; select * from t_pay where id=#&#123;id&#125; and payname=#&#123;payname&#125;&lt;/select&gt;推荐做法1：直接传入==业务逻辑数据模型==，如下：（这样也可以直接取）1public Pay getPay(Pay pay);123&lt;select id=\"getPay\" resultType=\"com.raven.pojo.Pay\"&gt; select * from t_pay where id=#&#123;id&#125; and payname=#&#123;payname&#125;&lt;/select&gt;推荐做法2：如果没有对应的==pojo==，那么可以定义并给方法传入一个 Map类型的对象，把要传递的参数值都put进map对象，之后把也可以向推荐做法1那样直接取值。mybatis中 #{} 和${}的区别？#{} 是已预编译的形式，将参数设置到sql语句，PreparedStatement也可以防止sql注入。（安全 ）${} 是 把 参数的值 直接拼装到sql语句中，会有安全问题。mybatis 如何返回 map类型，并且 指定 key 是自定义参数？​ 使用@MapKey标注在方法上即可，value的值为 map 封装 key 的字段属性12@MapKey(\"name\")public Map&lt;String,Pay&gt; getPayNameLike(String name);123&lt;select id=&quot;getPay&quot; resultType=&quot;map&quot;&gt; select * from t_pay where name like #&#123;name&#125;&lt;/select&gt;resultMap 标签详解如下图示例：我们使用了select标签的时候，查询某个pojo对象，这个对象的某个属性不是java的基本类型，而是一个对象，那么这个时候我们就可以使用到了 这个resutMap 属性，注意:在&lt;select&gt;标签里，要么使用resultMap要么使用resultType，只能使用一个，这个时候，我们就可以配置映射集了，即resultMap就是会我们封装对象的。看上图的&lt;association&gt;标签，其中的property属性代表了 当前==pojo对象的某个是对象的属性==，如我的值 是xsdcode,那么就是我这个实体类的xsdcode这个对象的这个属性是个对象。column 属性代表 这个属性对应的数据表字段。select属性代表 查询这个 属性对象的对应查询语句。即就是指向了它自己mapper文件的对应查询语句。​","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T12:19:57.599Z","updated":"2019-03-15T12:19:57.599Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]},{"title":"springboot整合websocket","slug":"springboot整合websocket的总结","date":"2019-03-10T11:44:31.759Z","updated":"2019-03-16T11:19:01.871Z","comments":true,"path":"2019/03/10/springboot整合websocket的总结/","link":"","permalink":"http://yoursite.com/2019/03/10/springboot整合websocket的总结/","excerpt":"","text":"springboot整合websocket的总结今天总结一下以往使用的websocket的两种方式|第一种：导入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt;​ 值得一提的是，导入 spring-boot-starter-web-services 之后，spring-boot-starter-web 这个场景启动器就可以不用加了，我们可以点开 spring-boot-starter-web-services 可以看到，spring-boot-starter-web-services 里面就有依赖spring-boot-starter-web ，所以无需重复添加新建一个配置类123456789101112import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@Configurationpublic class WebSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125; &#125;新建一个配置websocket的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.websocket;import java.io.IOException;import java.util.concurrent.CopyOnWriteArraySet; import javax.websocket.OnClose;import javax.websocket.OnError;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.ServerEndpoint; import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;@Slf4j@ServerEndpoint(value = \"/websocket\")@Componentpublic class WebSocketServer &#123; //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。 private static int onlineCount = 0; //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。 private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;(); //与某个客户端的连接会话，需要通过它来给客户端发送数据 private Session session; private final static Logger log = LoggerFactory.getLogger(WebSocketServer.class); /** * 连接建立成功调用的方法*/ public WebSocketServer() &#123; System.out.println(\"初始化！\"); &#125; @OnOpen public void onOpen(Session session) &#123; this.session = session; webSocketSet.add(this); //加入set中 addOnlineCount(); //在线数加1 log.info(\"有新连接加入！当前在线人数为\" + getOnlineCount()); try &#123; sendMessage(\"连接成功\"); &#125; catch (IOException e) &#123; log.error(\"websocket IO异常\"); &#125; &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose() &#123; webSocketSet.remove(this); //从set中删除 subOnlineCount(); //在线数减1 log.info(\"有一连接关闭！当前在线人数为\" + getOnlineCount()); &#125; /** * 收到客户端消息后调用的方法 * * @param message 客户端发送过来的消息*/ @OnMessage public void onMessage(String message, Session session) &#123; log.info(\"来自客户端的消息:\" + message); //群发消息 for (WebSocketServer item : webSocketSet) &#123; try &#123; item.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * * @param session * @param error */ @OnError public void onError(Session session, Throwable error) &#123; log.error(\"发生错误\"); error.printStackTrace(); &#125; public void sendMessage(String message) throws IOException &#123; session.getBasicRemote().sendText(message); &#125; /** * 群发消息 * */ public static void sendInfo(String message) throws IOException &#123; log.info(message); for (WebSocketServer item : webSocketSet) &#123; try &#123; item.sendMessage(message); &#125; catch (IOException e) &#123; continue; &#125; &#125; &#125; public static synchronized int getOnlineCount() &#123; return onlineCount; &#125; public static synchronized void addOnlineCount() &#123; WebSocketServer.onlineCount++; &#125; public static synchronized void subOnlineCount() &#123; WebSocketServer.onlineCount--; &#125;&#125;新建一个html文本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;WebSocket Echo Demo&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;script src=\"js/jquery-1.12.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var ws = new WebSocket(\"ws://localhost:8080/websocket\"); ws.onopen = function (e) &#123; console.log('Connection to server opened'); &#125; function sendMessage() &#123; ws.send($('#message').val()); &#125; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(received_msg); &#125;; ws.onclose = function()&#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; ws.onerror = function(err) &#123; alert(\"Error: \" + err); &#125;; &lt;/script&gt;&lt;/head&gt; &lt;body &gt; &lt;div class=\"vertical-center\"&gt; &lt;div class=\"container\"&gt; &lt;p&gt; &lt;/p&gt; &lt;form role=\"form\" id=\"chat_form\" onsubmit=\"sendMessage(); return false;\"&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"message\" id=\"message\" placeholder=\"Type text to echo in here\" value=\"\" /&gt; &lt;/div&gt; &lt;button type=\"button\" id=\"send\" class=\"btn btn-primary\" onclick=\"sendMessage();\"&gt; Send! &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;第二种：​ 第二种相对来说麻烦一点，需要配置握手拦截器（HttpSessionHandshakeInterceptor） 以及实现一个WebSocketConfigurer。1.老规矩 引入websocket依赖(具体版本可以自己添加 不过springboot 默认会由一个版本)12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt;2.配置一个Handle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package springboot;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import org.springframework.web.socket.CloseStatus; import org.springframework.web.socket.TextMessage; import org.springframework.web.socket.WebSocketHandler; import org.springframework.web.socket.WebSocketMessage; import org.springframework.web.socket.WebSocketSession; //extending either TextWebSocketHandler orBinaryWebSocketHandler public class MyHandler implements WebSocketHandler &#123; public Map&lt;WebSocketSession,String&gt; map = new HashMap&lt;WebSocketSession,String &gt;(); //连接关闭后 @Override public void afterConnectionClosed(WebSocketSession arg0, CloseStatus arg1) throws Exception &#123; // TODO Auto-generated method stub System.out.println(\"Connection closed...\"+arg0.getRemoteAddress().toString()); map.remove(arg0); &#125; //连接建立后 @Override public void afterConnectionEstablished(WebSocketSession arg0) throws Exception &#123; // TODO Auto-generated method stub System.out.println(\"Connection established...\"+arg0.getRemoteAddress().toString()); &#125; //收到消息后 @Override public void handleMessage(WebSocketSession arg0, WebSocketMessage&lt;?&gt; arg1) throws Exception &#123; // TODO Auto-generated method stub try &#123; if(map.containsKey(arg0)) &#123; System.out.println(\"Req: \"+arg1.getPayload()); TextMessage returnMessage = new TextMessage(map.get(arg0)+\":\"+arg1.getPayload().toString()); //arg0.sendMessage(returnMessage); SendAllUser(returnMessage); &#125;else &#123; map.put(arg0,arg1.getPayload().toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void SendAllUser(TextMessage returnMessage) &#123; // TODO Auto-generated method stub if(map.size()!=0) &#123; for (Entry&lt;WebSocketSession, String&gt; entry : map.entrySet()) &#123; try &#123; entry.getKey().sendMessage(returnMessage); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;//错误后(客户端强制断开) @Override public void handleTransportError(WebSocketSession arg0, Throwable arg1) throws Exception &#123; // TODO Auto-generated method stub if(arg0.isOpen())&#123; arg0.close(); &#125; map.remove(arg0); System.out.println(arg1.toString()); System.out.println(\"WS connection error,close...\"); &#125; @Override public boolean supportsPartialMessages() &#123; // TODO Auto-generated method stub return false; &#125; &#125;配置一个握手拦截器(拦截请求)1234567891011121314151617181920212223242526272829303132333435package springboot;import java.util.Map; import org.springframework.http.server.ServerHttpRequest; import org.springframework.http.server.ServerHttpResponse; import org.springframework.web.socket.WebSocketHandler; import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor; /** * * 类描述：握手拦截器 * com.watcher.websocket.spring MyHandshakeInterceptor * Created by 78098 on 2016年11月15日. * version 1.0 */ public class MyHandshakeInterceptor extends HttpSessionHandshakeInterceptor&#123; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; // TODO Auto-generated method stub System.out.println(&quot;After handshake &quot;+request.getRemoteAddress().toString()); super.afterHandshake(request, response, wsHandler, ex); &#125; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler handler, Map&lt;String, Object&gt; map) throws Exception &#123; // TODO Auto-generated method stub System.out.println(&quot;Before handshake &quot;+request.getRemoteAddress().toString()); return super.beforeHandshake(request, response, handler, map); &#125; &#125;4.实现配置类12345678910111213141516171819202122232425262728293031323334353637package springboot; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.config.annotation.EnableWebSocket; import org.springframework.web.socket.config.annotation.WebSocketConfigurer; import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry; @Configuration //配置类 @EnableWebSocket //声明支持websocket public class WebSocketConfig implements WebSocketConfigurer&#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; //注册websocket实现类，指定参数访问地址;allowed-origins=\"*\" 允许跨域 registry.addHandler(myHandler(), \"/ws\").addInterceptors(myHandshake()).setAllowedOrigins(\"*\"); //允许客户端使用SockJS registry.addHandler(myHandler(), \"/sockjs/ws\").addInterceptors(myHandshake()).withSockJS(); /* registry.addHandler(myHandler(), \"/webSocket\"); registry.addHandler(myHandler(), \"/webSocket/socketJs\").withSockJS();*/ &#125; @Bean public MyHandler myHandler()&#123; return new MyHandler(); &#125; @Bean public MyHandshakeInterceptor myHandshake()&#123; return new MyHandshakeInterceptor(); &#125; &#125;1以上就是springboot使用websocket的两种方法，用了websocket感觉真的挺简单的，原来，我们有了springboot,世界如此简单。还有一种node.js也可以搭建websocket后台服务器，那个就更简单了。。有兴趣的可以试试。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/categories/mybatis/"},{"name":"springboot","slug":"mybatis/springboot","permalink":"http://yoursite.com/categories/mybatis/springboot/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]}]}